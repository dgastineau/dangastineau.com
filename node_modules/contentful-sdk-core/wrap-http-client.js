'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = wrapHttpClient;

var _reduce = require('lodash/reduce');

var _reduce2 = _interopRequireDefault(_reduce);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _rateLimit = require('./rate-limit');

var _rateLimit2 = _interopRequireDefault(_rateLimit);

var _createBackoff = require('./create-backoff');

var _createBackoff2 = _interopRequireDefault(_createBackoff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Wraps the http client with a rate limiter, and a backoff functionality.
 * The rate limiter queues calls and attempts to prevent the server side rate
 * limit from ever being hit.
 * The backoff is triggered if a 429 Too Many Requests error is received from
 * the server, and every time if it is received repeateadly the wait time
 * for the next try will increase exponentially.
 * @private
 * @param {Object} http - HTTP Client instances
 * @param {Object} options - Options for the wrapper methods
 * @prop {number} concurrency - Number of allowed concurrent requests
 * @prop {number} delay - Delay in milliseconds for waiting after hitting the
 * allowed number of concurrent requests
 * @prop {number} maxRetries - Maximum number of retries when a 429 is received
 * @prop {boolean} retryOnTooManyRequests - If we should retry on 429s
 */
function wrapHttpClient(http, _ref) {
  var concurrency = _ref.concurrency,
      delay = _ref.delay,
      maxRetries = _ref.maxRetries,
      retryOnTooManyRequests = _ref.retryOnTooManyRequests;

  return (0, _reduce2.default)(['get', 'post', 'put', 'delete', 'patch', 'head'], function (http, methodName) {
    var httpCall = http[methodName].bind(http);
    if (retryOnTooManyRequests) {
      httpCall = maybeBackoff(httpCall, maxRetries);
    }
    http[methodName] = (0, _rateLimit2.default)(httpCall, concurrency, delay);
    return http;
  }, (0, _cloneDeep2.default)(http));
}

function maybeBackoff(fn, maxRetries) {
  return function httpCall() {
    var self = this;
    self.backoff = self.backoff || (0, _createBackoff2.default)(maxRetries);
    var args = Array.prototype.slice.call(arguments);
    var response = fn.apply(self, args);

    response = response.catch(function (error) {
      // Rate-limited by the server, maybe backoff and retry
      if (error.status === 429 || error.status >= 500) {
        return self.backoff(error, function () {
          return httpCall.apply(self, args);
        });
      }
      throw error;
    });

    return response;
  };
}