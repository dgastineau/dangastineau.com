'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.default = createBackoff;

var _promisedWait = require('./promised-wait');

var _promisedWait2 = _interopRequireDefault(_promisedWait);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a wrapper method which waits a given amount of time before calling
 * wrapped method.
 * If the call to the wrapped method fails, retries `maxRetries` times, and if
 * all those fail, it returns a rejected promise.
 * @private
 * @param {number} maxRetries - max number of retries before aborting
 */
function createBackoff(maxRetries) {
  var attempt = 0;
  return function maybeRetry(error, retry) {
    if (attempt < maxRetries) {
      var waitTime = error.headers && error.headers['X-Contentful-RateLimit-Reset'] || Math.pow(2, attempt);
      attempt++;
      // add a randomized buffer before recalling the api
      // The random buffer ensure that not all the backed-off requests are resent at the same time
      waitTime *= 1000 * (Math.random() * 1.2 + 1);
      return (0, _promisedWait2.default)(waitTime).then(retry);
    } else {
      return _promise2.default.reject(error);
    }
  };
}